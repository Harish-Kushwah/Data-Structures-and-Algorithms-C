slip-5
EX 1
/*
Q1. Create a random array of n integers. Accept a value x from user and use      
  linear search algorithm to check whether the number is present in the     
  array or not and output the position if the number is present.
*/
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int* createRandomArray(int n)
{
    int *arr=(int *)malloc(n*sizeof(int));
    srand(time(NULL));
    for(int i=0;i<n;i++)
    {
        arr[i]=rand()%10+1;
    }
    return arr;
}
int lsearch(int arr[],int n,int target)
{
    for(int i=0;i<n;i++)
    {
        if(arr[i]==target)
        return i;
    }
    return -1;
}
void printArr(int *arr,int n)
{
    printf("Random Element Array : ");
    for(int i=0;i<n;i++)
    {
        printf("%d ",arr[i]);
    }
    printf("\n");
}
int main()
{
    int n;
    printf("Enter N :");
    scanf("%d",&n);
    int target;
    printf("Enter target :");
    scanf("%d",&target);
    int *arr=createRandomArray(n);
    printArr(arr,n);
    int pos=lsearch(arr,n,target);
    if(pos!=-1)
    {
        printf("%d found at %d ",target,pos);
    }
    else{
        printf("%d is Not Found",target);
    }
    return 0;
}
----------------------------------------------------------------------------------------------------------
EX 2
/*
Q2. Implement a priority queue library (PriorityQ.h) of integers using a static 
implementation  of  the  queue  and  implementing  the  below  two  operations. 
Write  a  driver  program  that  includes  queue  library  and  calls  different  queue 
operations. 
1) Add an element with its priority into the queue. 
2) Delete an element from queue according to its priority.
*/
#include "PriorityQ.h"

void menu()
{
    printf("1]Enter to Enqueue \n");
    printf("2]Enter to dequeue \n");
    printf("3]Enter to Exit");
}
int main()
{
    Pqueue *pq=init();
    menu();
    while(1)
    {
        int key;
        printf("Enter key :");
        scanf("%d",&key);
        if(key==1)
        {
            int val,prio;
            printf("Enter value :");
            scanf("%d",&val);
            printf("Enter it's priority:");
            scanf("%d",&prio);
            enqueue(pq,val,prio);
        }
        else if(key==2)
        {
            printf("%d is Dequeued Element",dequeue(pq));
        }
        else{
            exit(0);
        }
        
    }
    return 0;

}
===========================================================================================================================
SLIP -8
EX1
/*
Q1. Implement a list library (singlylist.h) for a singly linked list of integer 
    With the operations create, delete specific element and display. Write a        
    menu driven program to call these operations
*/
#include "singlylist.h"
void menu()
{
    printf("1]Enter to create Node\n");
    printf("2]Enter to delete Node\n");
    printf("3]Enter to display List\n");
    printf("4]Enter to Exit\n");
}
int main()
{
    Node *head=NULL;
    menu();
    while(1){
    int key;
    printf("Enter Key:");
    scanf("%d",&key);
    if(key==1)
    {
        int n;
        printf("Enter How many Nodes wants to create :");
        scanf("%d",&n);
        head=createNode(n);
        if(head==NULL){
            printf("Sorry..!! Unable to create List\n");
        }
        else{
            printf("List created Successfully\n");
        }
    }
    else if(key==2)
    {
        int val;
        printf("Enter value for delete :");
        scanf("%d",&val);
        head=delateByVal(head,val);
        if(head==NULL){
            printf("Sorry..!! Unable to delete\n");
        }
        else{
            printf("Target value deleted Successfully\n");
        }
    }
    else if(key==3)
    {
        printf("Linked List is :\n");
        display(head);

    }
    else if(key==4){
        exit(0);
    }
    else{
        printf("Enter a valid key\n");
    }
  } 
    return 0;
}

//FILE singly.h
#include<stdio.h>
#include<stdlib.h>

typedef struct Node
{
    int val;
    struct Node *next;
}Node;

Node *createNode(int n)
{
    Node *head=NULL,*temp=NULL,*newnode=NULL;
    for(int i=0;i<n;i++)
    {
        newnode=(Node *)malloc(sizeof(Node));
        printf("Enter value :");
        scanf("%d",&newnode->val);
        newnode->next=NULL;
        if(head==NULL)
        {
            head=temp=newnode;
        }
        else
        {
            temp->next=newnode;
            temp=newnode;
        }
    }
    return head;
}
void display(Node *head)
{
    for(Node *temp=head;temp!=NULL;temp=temp->next)
    {
        printf("%d ",temp->val);
    }
    printf("\n");
}
Node *delateByVal(Node *head,int val)
{
    if(val==head->val)
    {
            Node *t=head;
            head=head->next;
            free(t);
  }
  else{
       Node *p1=head;
    for(Node *temp=head;temp!=NULL;temp=temp->next)
    {
        
        if(val==temp->val)
        {
            Node *t=temp;
            p1->next=temp->next;
            temp=temp->next;
            free(t);
        }
        else{
            p1=temp;
        }
    }
    }

return head;
}
--------------------------------------------------------------------------------------------------------------------------
/*
Q2. Write a C program to check whether the contents of two stacks are        
   identical. Use stack library to perform basic stack operations. Neither          
   stack should be changed
*/
#include "stack.h"

int isEqual(Stack *st1,Stack *st2,int capacity)
{
    Stack *t1=init(5);
    Stack *t2=init(5);
    while(!isEmpty(st1)&&!isEmpty(st2))
    {
        push(t1,pop(st1));
        push(t2,pop(st2));
    }
    int flag=1;
    while(!isEmpty(t1)&&!isEmpty(t1))
    {
        int a=pop(t1);
        int b=pop(t2);
        if(a!=b){
            flag=0;
        }
        push(st1,a);
        push(st2,b);
    }
    return flag==1;
}
int main()
{
    int capacity;
    printf("Enter Capacity of Both stack");
    scanf("%d",&capacity);
    Stack *st1=init(capacity);
    Stack *st2=init(capacity);

    int n1;
    printf("Enter Data in stack 1:\n");
    printf("Enter how many elements wants to store :");
    scanf("%d",&n1);
    for(int i=0;i<n1;i++){
        int val;
        printf("Enter val :");
        scanf("%d",&val);
        push(st1,val);
    }
    int n2;
    printf("Enter Data in stack 1:\n");
    printf("Enter how many elements wants to store :");
    scanf("%d",&n2);
    for(int i=0;i<n2;i++){
        int val;
        printf("Enter val :");
        scanf("%d",&val);
        push(st2,val);
    }
   
    if(isEqual(st1,st2,capacity))
    {
        printf("Content Of both Stack is Equal\n");
    }
    else{
        printf("Content is different\n");
    }
}

//stack.h
#include<stdio.h>
#include<stdlib.h>

typedef struct Stack
{
    int capacity;
    int *arr;
    int top;
}Stack;

Stack* init(int capacity)
{
    Stack *stk=(Stack*)malloc(sizeof(Stack));
    stk->top=-1;
    stk->capacity=capacity;
    stk->arr=(int *)malloc(capacity*(sizeof(int)));
    return stk;
}
int isEmpty(Stack *stk)
{
    return stk->top==-1;
}
int isFull(Stack* stk)
{
    return stk->top==stk->capacity-1;
}
void push(Stack *stk,int val)
{
    if(stk->top==stk->capacity-1)
    {
      printf("Stack is Full\n");
    }
    else{
        stk->arr[++stk->top]=val;
    }
}
int pop(Stack *stk)
{
    if(stk->top==-1)
    {
        printf("Stack is Empty\n");
    }
    else
    {
        return stk->arr[stk->top--];
    }
}
==============================================================================================
SLIP-10
ex 1
/*
Q1.  Implement  a  linear  queue  library  (st_queue.h)  of  integers  using  a  static 
implementation of the queue and implementing the init(Q), add(Q) and peek(Q) 
operations.  Write  a  program  that  includes  queue  library  and  calls  different 
queue operations
*/
#include "st_queue.h"
void menu()
{
    printf("1]Enter to initialize queue\n");
    printf("2]Enter to add element in queue\n");
    printf("3]Enter To get peek element from queue\n");
    printf("4]Enter to Exit\n");
}
int main()
{
    menu();
    int key;
    Queue *Q=NULL;
    while(1){
    printf("\nEnter key :");
    scanf("%d",&key);
    if(key==1)
    {
        Q=init(Q);
        if(Q==NULL)
        {
            printf("Sorry..!! Unable to initialize Queue\n");
        }
        else{
            printf("Queue initialize Successfully\n");
        }
    }
    else if(key==2)
    {
         if(Q==NULL)
        {
            printf("Sorry..!! First initialize Queue\n");
            break;
        }
        int val;
        printf("\nEnter val :");
        scanf("%d",&val);
        add(Q,val);
    }
    else if(key==3)
    {
        if(Q==NULL)
        {
            printf("Sorry..!! First initialize Queue\n");
            break;
        }
        printf("Peek Element is : %d\n",peek(Q));
    }
    else if(key==4)
    {
        free(Q);
        exit(0);
    }
    else{
        printf("Enter Valid case\n");
    }
    }
    return 0;

}
//st_queue.h FILE

#include<stdio.h>
#include<stdlib.h>
#define N 20
typedef struct Queue
{
    int arr[N];
    int front;
    int rare;
}Queue;

Queue* init(Queue *qu)
{
    qu=(Queue*)malloc(sizeof(Queue));
    qu->front=-1;
    qu->rare=-1;
    return qu;
}
void add(Queue *qu,int val)
{
    if(qu->rare==N-1)
    {
        printf("Queue is Full");
    }
    else
    if(qu->front==-1&&qu->rare==-1)
    {
        qu->front=qu->rare=0;
        qu->arr[qu->rare]=val;
    }
    else{
        qu->arr[++qu->rare]=val;
    }
}
int peek(Queue *qu)
{
    if(qu->front==-1&&qu->rare==-1)
    {
        printf("Queue is Empty\n");
    }
    else{
        return qu->arr[qu->front];
    }
}

---------------------------------------------------------------
EX2
/*
Q2.  Read  the  data  from  the  file  “employee.txt”  and  sort  on  names  in 
alphabetical order (use strcmp) using bubble sort and selection sort
*/
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct Employee
{
    int emp_Id;
    char emp_Name[20];
}Employee;

int readFile(Employee emp[])
{
    FILE *fp=fopen("employee.txt","r");
    if(fp==NULL)
    {
        printf("Unable To open File\n");
        exit(0);
    }
    
    int i=0;
    while(!feof(fp))
    {
      fscanf(fp,"%d%s",&emp[i].emp_Id,emp[i].emp_Name);
      strupr(emp[i].emp_Name);
      i++;
    }
    return i;
}
void swap(Employee *emp,Employee*emp2)
{
    Employee ep=*emp;
    *emp=*emp2;
    *emp2=ep;
}
void bubbleSort(Employee emp[],int n)
{
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n-(i+1);j++)
        {
            int cmp=strcmp(emp[j].emp_Name,emp[j+1].emp_Name);
            if(cmp>0)
            {
                 swap(&emp[j],&emp[j+1]);
            }
        }
    }
}

void selectionSort(Employee emp[],int n)
{
    for(int i=0;i<n;i++)
    {
        Employee minEmp=emp[i];
        int index=i;
        for(int j=i;j<n;j++)
        {
           int cmp=strcmp(minEmp.emp_Name,emp[j].emp_Name);
           if(cmp>0)
           {
             minEmp=emp[j];
             index=j;
           }
        }
        swap(&emp[i],&emp[index]);
        
    }
}
void printData(Employee emp[],int n)
{
    for(int i=0;i<n;i++)
    {
        printf("%d %s\n",emp[i].emp_Id,emp[i].emp_Name);
    }
}
int main()
{
    Employee emp[10];
    int n=readFile(emp);
    selectionSort(emp,n);
    printData(emp,n);
}

//employee.txt
1 Harish
2 Rohan
3 Pratik
4 Rupesh
6 Adesh
========================================================================================================================
slip-13
/*
Q1. Read the data from file 'cities.txt' containing names of cities and their STD 
codes.  Accept  a  name  of  the  city  from  user  and  use  sentinel  linear  search 
algorithm to check whether the name is present in the file and output the STD 
code, otherwise output “city not in the list”
*/

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct Cities
{
    int STD;
    char Name[20];
}Cities;

int readFile(Cities city[])
{
    FILE *fp=fopen("cities.txt","r");
    if(fp==NULL)
    {
        printf("Unable to open file\n");
        exit(0);
    }
    int i=0;
    while(!feof(fp))
    {
        fscanf(fp,"%d%s",&city[i].STD,city[i].Name);
        strupr(city[i].Name);
        i++;
    }
    return i;
}
int sentinelSearch(Cities city[],char target[],int n)
{
    char last[20];
    strcpy(last,city[n-1].Name);
    strcpy(city[n-1].Name,target);
    int i=0;
    while(strcmp(city[i].Name,target)!=0){
        i++;
    }
    strcpy(city[n-1].Name,last);
    if(i<n-1||strcmp(city[n-1].Name,target)==0)
    {
        if(i<n-1)
        return i;
        return n-1;
    }
    else{
        return -1;
    }
}
int binSearch(Cities city[],char target[],int n)
{
    int low=0;
    int upp=n-1;
    while(low<=upp)
    {
        int mid=(upp+low)/2;
        int cmp=strcmp(target,city[mid].Name);
        if(cmp==0)
        {
            return mid;
        }
        else if(cmp>0)
        {
            low=mid+1;
        }
        else{
            upp=mid;
        }
    }
    return -1;
}
int main()
{
    Cities city[10];
    int n=readFile(city);
    char target[20];
    printf("Enter target :");
    scanf("%s",target);
    strupr(target);
    int i=binSearch(city,target,n);
    if(i==-1){
        printf("City is Not present\n");
    }
    else{
        printf("%d is STD code of city %s\n",city[i].STD,city[i].Name);
    }
}
-------------------------------------------------------------------------------------
EX2
/*
Q2. Implement a priority queue library (PriorityQ.h) of integers using a static 
implementation  of  the  queue  and  implementing  the  below  two  operations. 
Write  a  driver  program  that  includes  queue  library  and  calls  different  queue 
operations.
 1) Add an element with its priority into the queue.    
 2) Delete an element from queue according to its priority.
*/
#include "PriorityQ.h"
int main()
{
   Pqueue *pq=init(pq);
   enqueue(pq,1,2);
   enqueue(pq,2,4);
   enqueue(pq,4,1);
   printf("%d\n",dqueue(pq));
   printf("%d\n",dqueue(pq));
   printf("%d\n",dqueue(pq));


}
//PriorityQ.h file
#include<stdio.h>
#include<stdlib.h>
#define N 10
typedef struct data
{
    int prio;
    int val;
}data;

typedef struct pqueue
{
    data arr[N];
    int front;
    int rare;
}Pqueue;

Pqueue* init(Pqueue *pq)
{
    pq=(Pqueue*)malloc(sizeof(Pqueue));
    pq->front=-1;
    pq->rare=-1;
    return pq;
}
int size=0;
void enqueue(Pqueue *pq,int val,int prio)
{
    if(pq->front==0 &&pq->rare==N-1)
    {
        printf("Queue is Full");
    }
    else{
         if(pq->front==-1&&pq->rare==-1){
       pq->front=pq->rare=0;
       pq->arr[pq->rare].val=val;
       pq->arr[pq->rare].prio=prio;
      }
      else{
        pq->rare++;
        pq->arr[pq->rare].val=val;
        pq->arr[pq->rare].prio=prio;
      }
    size++;
    }
}
int dqueue(Pqueue *pq)
{
    int maxPrio=-1;
    int ind=-1;
    for(int i=0;i<=size;i++)
    {
        if(maxPrio<pq->arr[i].prio)
        {
            maxPrio=pq->arr[i].prio;
            ind=i;
        }
    }
    int val=pq->arr[ind].val;
    for(int i=ind;i<size;i++)
    {
        pq->arr[i]=pq->arr[i+1];
    }
    return val;
}
==========================================================================================================================================
SLIP 13
EX1/*
Q1. Implement a stack library (ststack.h) of integers using a static 
implementation  of  the  stack  and  implementing  the  operations  like  init(S), 
S=push(S)  and  S=pop(S).  Write  a  driver  program  that  includes  stack  library 
and calls different stack operations.
*/
#include "ststack.h"
void menu()
{
    printf("1]Enter to Create stack\n");
    printf("2]Enter to push Element\n");
    printf("3]Enter to pop Element\n");
    printf("4]Enter to exit\n");

}
int main()
{
    menu();
    int key;
    Stack *stk=NULL;
    while(1){
    printf("\nEnter key :");
    scanf("%d",&key);
    if(key==1)
    {
     stk=init(stk);
     if(stk==NULL)
     {
        printf("Sorry..!! Unable to initialize\n");
     }
     else{
        printf("Stack is initialized successfully\n");
     }
    }
    else if(key==2)
    {
        int val;
        printf("Enter val:");
        scanf("%d",&val);
        push(stk,val);
    }
    else if(key==3)
    {
        printf("Pop  element is :%d",pop(stk));
    }
    else if(key==4)
    {
        break;
    }
    }
}
// ststack.h file
#include<stdio.h>
#include<stdlib.h>
#define N 20
typedef struct Stack
{
    int arr[N];
    int top;
}Stack;

Stack* init(Stack *stk)
{
    stk=(Stack *)malloc(sizeof(Stack));
    stk->top=-1;
    return stk;
}
int isEmpty(Stack *stk)
{
    return stk->top==-1;
}
int isFull(Stack *stk)
{
    return stk->top==N-1;
}
void push(Stack *stk,int val)
{
    if(stk->top==N-1)
    {
        printf("Stack is Full\n");
    }
    else{
    stk->arr[++stk->top]=val;
    }
}
int pop(Stack *stk)
{
    if(stk->top==-1)
    {
        printf("Stack is Empty\n");
    }
    else{
        return stk->arr[stk->top--];
    }
}
int peek(Stack *stk)
{
    if(stk->top==-1)
    {
        printf("Stack is Empty\n");
    }
    else{
        return stk->arr[stk->top];
    }
}
----------------------------------------------------------------------------------------------------------------------------
EX2
/*
Q2.  Write  a  program  that  sorts  the  elements  of  linked  list  using  bubble  sort 
technique
*/
#include<stdio.h>
#include<stdlib.h>
struct Node
{
  int val;
  struct Node *next;
};
struct Node* createNode(int n)
{
  struct Node *head=NULL;
  struct Node *newnode=NULL;
  struct Node *temp=NULL;
  
  for(int i=0;i<n;i++){
    newnode=(struct Node *)malloc(sizeof(struct Node ));
    printf("Enter value :");
    scanf("%d",&newnode->val);
    newnode->next=NULL;

    if(head==NULL)
    {
      head=newnode;
      temp=newnode;
    }
    else{
      temp->next=newnode;
      temp=newnode;
    }
  }
  return head;
}

Node* bubbleSort(Node *head)
{
    for(Node *temp=head;temp!=NULL;temp=temp->next)
    {
        for(Node *temp1=temp;temp1->next!=NULL;temp1=temp1->next)
        {
            if(temp1->val<temp1->next->val)
            {
              int val=temp1->val;
              temp1->val=temp1->next->val;
              temp1->next->val=val;
            }
        }
    }
    return head;
}
void printList(struct Node *head)
{
  struct Node *temp=head;
  while(temp!=NULL)
  {
    printf("%d ",temp->val);
    temp=temp->next;
  }
  printf("\n");
}

int  main()
{
  Node *head=createNode(5);
  printList(head);
  bubbleSort(head);
  printList(head);
        
}
=========================================================================================
slip-27
EX2
/*
Q2.Read  the  data  from  the  file  and  sort  on  names  in  alphabetical  order  (use 
strcmp)  using Counting  sort,  Merge  sort  and  write the sorted data to  another 
file 'sortedemponname.txt'    

*/
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct Employee
{
    int Id;
    char Name[20];
}Employee;

int readFile(Employee emp[])
{
    FILE *fp=fopen("employee.txt","r");
    if(fp==NULL)
    {
        printf("Unable to open file\n");
        exit(0);
    }
    int i=0;
    while(!feof(fp))
    {
        fscanf(fp,"%d%s",&emp[i].Id,emp[i].Name);
        i++;
    }
    return i;
}
void writeFile(Employee emp[],int n)
{
    FILE *fp=fopen("sortedEmp.txt","w");
    if(fp==NULL)
    {
        printf("Unable to open file\n");
    }
    for(int i=0;i<n;i++)
    {
        fprintf(fp,"%d\t%s\n",emp[i].Id,emp[i].Name);
    }
}
void merge(Employee emp[],int low,int mid,int upp)
{
    int i=low;
    int j=mid+1;
    int k=low;
    Employee b[low+upp];
    while(i<=mid&&j<=upp)
    {
        int cmp=strcmp(emp[i].Name,emp[j].Name);
        int cmp1=strcmp(emp[j].Name,emp[i].Name);
        if(cmp==0||cmp<0)
        {
            b[k]=emp[i];
            i++;
            k++;
        }
        if(cmp1==0||cmp1<0)
        {
            b[k]=emp[j];
            k++;
            j++;
        }
    }
    if(i>mid)
    {
        while(j<=upp)
        {
            b[k]=emp[j];
            k++;
            j++;
        }
    }
    else{
        while(i<=mid)
        {
            b[k]=emp[i];
            i++;
            k++;
        }
    }
    for(k=low;k<=upp;k++)
    {
        emp[k]=b[k];
    }
}
void mergeSort(Employee emp[],int low,int upp)
{
    if(low<upp)
    {
        int mid=(low+upp)/2;
        mergeSort(emp,low,mid);
        mergeSort(emp,mid+1,upp);
        merge(emp,low,mid,upp);
    }
}
int main()
{
    Employee emp[10];
   int n=readFile(emp);
    mergeSort(emp,0,n-1);
    writeFile(emp,n);
}
---------------------------------------------------------------------------------------------------------
EX1
#include<stdio.h>
#include<stdlib.h>

typedef struct Poly
{
    float coeff;
    int expo;
    struct Poly *next;
}Poly;

//insert nodes in sorted order
Poly *insert(Poly *head,float coeff,int expo)
{
    Poly *newnode=NULL,*temp=NULL;
    newnode=(Poly *)malloc(sizeof(Poly));
    newnode->coeff=coeff;
    newnode->expo=expo;
    newnode->next=NULL;
    int key=expo;
    if(head==NULL||key>head->expo)
    {
        newnode->next=head;
        head=newnode;
    }
    else{
        temp=head;
        while(temp->next!=NULL&&temp->next->expo>key)
        temp=temp->next;

        newnode->next=temp->next;
        temp->next=newnode;

    }
 return head;
}
Poly *createPoly(int n)
{
    float coeff;
    int expo;
    Poly *head=NULL;
    for(int i=0;i<n;i++)
    {
        printf("Enter Coeff:");
        scanf("%f",&coeff);
        printf("Enter expo :");
        scanf("%d",&expo);
        head=insert(head,coeff,expo);
    }
    return head;
}
void printList(Poly *head)
{
    if(head==NULL)
    printf("No Polynomial");
    else
    {
        for(Poly *temp=head;temp!=NULL;temp=temp->next)
        {
            printf("(%0.1f x)^%d",temp->coeff,temp->expo);
            if(temp->next!=NULL)
            printf(" + ");
        }

    }
    printf("\n");
}

Poly* add(Poly *head1,Poly *head2)
{
    Poly *head=NULL;  //polynomial 3
    Poly *p1=head1;
    Poly *p2=head2;

    while(p1!=NULL&&p2!=NULL)
    {
        if(p1->expo==p2->expo)
        {
            head=insert(head,p1->coeff+p2->coeff,p1->expo);
            p1=p1->next;
            p2=p2->next;
        }
        else if(p1->expo<p2->expo)
        {
            head=insert(head,p2->coeff,p2->expo);
            p2=p2->next;
        }
        else{
            head=insert(head,p1->coeff,p1->expo);
            p1=p1->next;
        }
    }
    while(p1!=NULL)
    {
        head=insert(head,p1->coeff,p1->expo);
        p1=p1->next;
    }
    while(p2!=NULL)
    {
        head=insert(head,p2->coeff,p2->expo);
        p2=p2->next;
    }
    return head;
}
Poly *head[10];
void multiply(Poly *head1,Poly *head2,int terms)
{
    for(int i=0;i<terms;i++){
        Poly *head[i]={NULL};
    }
    int i=0;
    for(Poly *p1=head1;p1!=NULL;p1=p1->next)
    {
        for(Poly *p2=head2;p2!=NULL;p2=p2->next)
        {
            head[i]=insert(head[i],p1->coeff*p2->coeff,p1->expo+p2->expo);
        }
        i++;
    }
    for(int i=0;i<terms;i++)
    {
        head[i+1]=add(head[i],head[i+1]);
    }
    printList(head[terms-1]);
}

void multiply1(Poly *head1,Poly *head2)
{
    Poly *head=NULL;
    int i=0;
    for(Poly *p1=head1;p1!=NULL;p1=p1->next)
    {
        for(Poly *p2=head2;p2!=NULL;p2=p2->next)
        {
            head=insert(head,p1->coeff*p2->coeff,p1->expo+p2->expo);
        }
        i++;
    }
    for(Poly *p3=head;p3->next!=NULL;)
    {
        if(p3->expo==p3->next->expo){
            p3->coeff=p3->coeff+p3->next->coeff;
            Poly *temp=p3->next;
            p3->next=p3->next->next;
            free(temp);
            temp=NULL;
        }
        else{
            p3=p3->next;
        }
    }
    printList(head);
}
int main()
{
    int n1,n2;
    printf("Number of terms of poly 1:");
    scanf("%d",&n1);
    Poly *p1=createPoly(n1);
    printList(p1);
    printf("Number of terms of poly 2:");
    scanf("%d",&n2);
    Poly *p2=createPoly(n2);
    printList(p2);
    printf("polynomial :");
    multiply1(p1,p2);
    return 0;
}